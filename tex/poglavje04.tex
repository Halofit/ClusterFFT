\chapter[Zmogljivst Beowulf gruèe Raspberry Pi raèunalnikov \\ (G. Vitek,  Ž. Palèiè, M. Smerkol)]{Zmogljivst Beowulf gruèe Raspberry Pi raèunalnikov}
\huge Gregor Vitek, Žan Palèiè, Maj Smerkol\\
\normalsize
\bigskip

\section{Uvod}

Na spletu lahko najdemo že opravljene znane benchmarke\cite{4Benchmarks}, ki ocenjujejo doloèene lastnosti oblaènih sistemov (S2). Tu lahko najdemo podatke o procesni moèi sistema, ki ga dobimo v uporabo, kolièini pomnilnika na takšnem sistemu in zmogljivosti opravljanja nekaterih znanih testov, kot so naprimer urejanje velike kolièine podatkov. Te meritve, ki jih lahko preberemo med že opravljenimi testi, pa ne kažejo na zmogljivost neke doloèene storitve, kot jo doživlja uporabnik, ampak samo povejo, kako zmogljiva je strojna oprema, ki jo dobimo na voljo. Konènega uporabnika storitve ponavadi zanima predvsem hitrost odzivanja, ki je odvisna od veè parametrov.
Med slednje spadajo hitrost in latenca povezave od naprave uporabnika (angl. \textit{end point}) do fiziène lokacije oblaène storitve ali strežnika, velikost poslanega zahtevka, hitrost odbelave zahtevka, hitrost in latenca poslanega odgovora iz oblaka ali strežnika proti uporabniku in drugo. Pri tem lahko lahko nekatere storitve implementiramo na tak naèin, da uporabnik verjame, da je odzivni èas veliko manjši, kot dejansko je (naprimer shranjevanje datotek na disk v oblaku). Na konèno uporabnikovo izkušnjo hitrosti vpliva tudi zmogljivost naprave, ki predstavlja njegovo dostopno toèko. 

Kot omenjeno zgoraj se na spletu najdejo seznami spletnih sistemov, ki jih lahko uporabniki med seboj primerjajo. Primerjajo lahko rezultate za razliène parametre kot so hitrost procesorja pri raèunanju s plavajoèo vejico ali celimi števili, hitrost prenosa pri branju podatkov oz. pisanju na pomnilnih enotah, hitrost prenosa podatkov lokalno znotraj oblaène storitve in drugo. Pri testiranju teh parametrov se lahko uporabi razlièna orodja kot so SPEC CPU 2006, Test Harness, TeraSort, Geekbench in še mnogo drugih. Pri sami izbiri programov se moramo osredotoèiti tudi na bremena, ki jih lahko s posameznim programom definiramo in tako testiramo željene parametre. Kljuèen kriterij poleg kakovosti storitev in definiranje bremen je tudi cena. Zaželjeni so prosto dostopni oz. zastonjski progami. 

Pri testiranju spletnih strežnikov (S1) uporabnika navadno zanima število zahtev, ki jih strežnik obdela, latenca oz. èas odziva strežnika za novo povezavo ali zahtevek, in kolièina prenesenih podatkov v sekundi, glede na razliène parametre (velikost, shranjevanje v predpomnilnik, razlièna pasovna širina). Za izvajanje stresnih testov se na spletu nahaja veliko orodij, ki lahko pridejo v pomoè (Apachech, Apache JMeter, Curl-loader, OpenSTA). 

\subsection{Znanje}

Sistem, ki ga bomo testirali, smo izbrali na podlagi svojega znanja in zanimanja. 
Èlani te skupine imamo predznanje iz arhitekture in organizacije raèunalniških sistemov, kot so procesne enote, pomnilniška hierarhija in vhodno/izhodne naprave. Poznamo tudi paralelno programiranje na razliènih platformah v jeziku C, kar bi nam lahko pomagalo pri optimizaciji doloèenih storitev. Imamo predznanje iz strežniških arhitektur in osnov spletne komunikacije. Imamo tudi omejene izkušnje uporabe PaaS (angl. \textit{platform as a service}) za postavitev spletnih strani in postavitve podakovnih baz na teh strežnikih. Nimamo pa izkušenj s testiranjem in merjenjem zmogljivosti katerega koli on naštetih modelov.

\begin{figure}[htbf]
\centerline{\includegraphics[scale=0.5]
{4_vzorec.eps}}
\caption{Odvisnost izbire S1 in S2 glede na podane atribute.}
\label{fig:miselni}
\end{figure}

\subsection{Izbira ciljnih sistemov}

Za ciljni sistem bi lahko izbrali kakšnega od veèjih ponudnikov oblaènih storitev kot so Google Cloud, Amazon web service, Microsoft Azure, lahko tudi kakšnega manjšega, naprimer Rackspace. Veèina teh ponudnikov ima omejene zastonjska testna obdobja, med katerimi bi lahko izvedli meritve.
Ker imamo dostop do raèunalnika Raspberry Pi \footnote{http://www.raspberrypi.org/} in predvsem zastonjskih verzij oblaènih storitev, nas zanima primerjava med temi platformami. Raspberry Pi je raèunalnik, ki stane okrog 30 evrov in ne porabi praktièno niè elektrike, v zameno pa ponuja primerno majhno zmogljivost. Ne plaèljive oblaène storitve so moèno èasovno omejene ali pa ponujajo prav tako zelo majhne zmogljivosti.
Zaradi naših predznanj lahko storitev za strežnik (glej sliko \ref{fig:miselni}), katerega ustroj in delovanje poznamo, bolje optimiziramo, kot oblaèno storitev, kar je prav tako vredno preveriti.

Ker pa je implementacija optimizirane storitve in postavitev lastne gruèe relativno zahtevno opravilo, mi pa imamo na voljo omejen èas, smo se odloèili za testiranje zmogljivosti gruèe raèunalnikov Raspberry Pi. Le ti so se v zadnjem èasu zaradi nizke cene na mnogih podroèjih raèunalništva zaèeli uporabljati. Nas zanima, ali so raèunalniki takšnega tipa primerni tudi za uporabo na podroèjih, ki zahtevajo raèunsko moè. Na podlagi izmerjenih rezultatov lahko primerjamo zmogljivost z drugaènimi sistemi, na katerih so meritve že opravljene. Prav tako lahko nadaljujemo raziskovanje na tem podroèju z poskusom optimizacije enake storitve na drugaènem sistemu v prihodnosti.

\subsection{Breme in cilj primerjave}

Za storitev, ki jo bo naša gruèa ponujala, smo izbrali manipulacijo nad frekvenènim spektrom avdio datotek. To pomeni, da smo implementirali porazdeljen algoritem FFT, ki pretvori datoteko iz vzorènega prostora v frekveèni spekter, nato nad tem opravimo preprosto operacijo, na primer zamik v višje frekvence, nato pa z inverznim FFT spet naredimo datoteko v vzorènem prostoru.

Bremena so tako razlièno velike zvoène datoteke. Ker naš spletni strežnik, ki to storitev ponuja, sprejme eno ali veè datotek, testiramo tudi izvajanje veèih instanc algoritma hkrati.

Cilj primerjave je ugotoviti, ali je raèunalnik Raspberry Pi primeren za postavitev gruèe, ki bo izvajala raèunsko zahtevne storitve. Da bi to ugotovili, moramo primerjati èas izvajanja na procesorju, èas latence oddaljenega sistema prek medmrežja in èas pošiljanja podatkov po gruèi.

\section{Sistem}

%%%%%%%%%%%%%%%%%%% FOTOGRAFIJA %%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[H]
\centerline{\includegraphics[scale=0.1]
{4_foto.eps}}
\caption{Fotografija gruèe. Na levi je 100 megabitno stikalo, na desni pa raèunalniki Raspberry Pi na pladnju.}
\label{fig:foto}
\end{figure}

Naš sistem je gruèa raèunalnikov, narejena po vzoru Beowulf gruè (glej sliko \ref{fig:foto}). Namenjena je zaganjanju porazdeljenih programov. V mrežo smo povezali štiri raèunalnike Raspberry Pi, model 1B, tri modele 1B+. Povezani so v gruèo s pomoèjo knjižnjice MPI\footnote{Message Passing Interface, knjižnjica za medprocesno komunikacijo prek omrežja ali na lokalnem raèunalnikom}. Do njega imamo SSH dostop tudi z zunanjega omrežja. Storitev je dostopna prek strežnika, ki smo ga implementirali sami. Programska koda strežnika in implementacije algoritma FFT je v prilogi.

\begin{figure}[H]
\centerline{\includegraphics[scale=1.5]
{4_shemaSistema.eps}}
\caption{Shema sistema. Rdeèi kvadrati so raèunalniki Raspberry Pi.}
\label{fig:gruca}
\end{figure}

Do tega sistema dostopamo s klienti, ki so izven lokalnega omrežja (glej sliko \ref{fig:gruca}). Gruèo uporabljamo kot raèunski strežnik, ki po zahtevi klienta izvaja porazdeljeno hitro Fourierjevo transformacijo. Klient prek omrežja pošlje podatke v obliki glasbene datoteke, gruèa pa podatke sprejme (to stori strežnik, ki teèe na master raèunalniku gruèe) in izvajanje algoritma porazdeli prek vseh raèunalnikov v gruèi, vkljuèno s sabo.

Gruèa se nahaja na Velikem Loèniku, na omrežju Telekoma. Dostopna je prek širokopasovne povezave po optiènem kablu (angl. \textit{FTTH - fiber to the home}) s hitrostjo 20Mb/s v obe smeri. Vse povezave po hiši so po bakreni parici kategorije 6, omrežna oprema pa je prepustna najmanj 100Mb/s.

V zaèetku smo testirali dostop do gruèe od zunaj in delovanje sistema MPI na raèunalniku rpi1. To smo storili tako, da smo na njem poganjali z MPI implementiran algoritem porazdeljeni Quicksort (porazdeljeno hitro urejanje\footnote{http://en.wikipedia.org/wiki/Quicksort\#Parallelization}).

Pri povezovanju Raspberry Pi-jev v gruèo smo uporabili Message Passing Interface(MPI), ki je standard za izmenjevanje sporoèil med raèunalniki oz. procesih v veè-raèunalniških sistemih, gruèah in delovnih postajah. Omogoèa komunikacijo toèka-toèka, skupinske komunikacije, spremljanje delovanja in tudi spreminjanje topologije za posamezen program. MPI je standard, ki omogoèa velik nabor funkcij, vendar za uporabo standarda ni potrebno poznati vseh. Pri sami komunikaciji raèunalniki med seboj uporabljajo implementacijo MPICH2 \cite{4Mpich},
ki je zelo razširjena programska knjižnica, ki je enostavna za vzpostavitev in uporabo. Na vsakem raèunalniku je implementacija 
MPICH2 in datoteka (machinefile)\cite{4Gruca}, v kateri so zapisani IP naslovi sodelojoèih (sosednjih) lokalnih raèunalnikov, na katere se delo porazdeli.

Implementirali smo porazdeljeni algoritem FFT, ki se izvaja na gruèi. 

\subsection{Implementacija storitve}

V gruèo smo dodali veè raèunalnikov, da je prava gruèa, ne le en raèunalnik, na katerem teèe MPI. Raspberry Pi smo pripravili na delovanje v gruèi tako, da smo klonirali sliko datoteènega sistema. Potrebni so bili popravki v konfiguraciji omrežja in sprememba hostname-a vsakega raèunalnika. Po tem je gruèa delovala brez težav.

Implementirali smo storitev, ki zvoèno datoteko pretvori v binarno s pomoèjo knjižnjice \texttt{libsndfile}\cite{4Audio}. Testiranje smo izvedli z zvoèno datoteko, veliko približno 8 miljonov vzorcev (okrog 3 minute zvoka, nekompresirana velikost je okrog 15MB). Program na enem jedru teèe zelo poèasi. Ni se izpolnil strah, da bi algoritem tekel prehitro, da bi se ga izplaèalo poganjati na gruèi. Imeli smo nekaj težav s kodiranjem datoteke nazaj v zvoèno datoteko.

Pretvorbo izvajamo z rekurzivnim algoritmom FFT. Implementacija je zaradi uporabe razreda ValArray iz knjižnjice STL poèasna, èe je prevanjanje izvedeno z Microsoft Visual Studio prevajalnikom. Program, ki se izvaja na gruèi, na kateri teèe Linux (distribucija Arch Linux), je preveden s prevajalnikov gcc, ki se v tem primeru obnaša veliko bolje - koda se izvaja hitreje.

\vspace{10pt}

Implementirali smo strežnik, ki sprejema zahtevke z eno ali veè datotekami in nato odgovori. Implementirali smo tudi klienta, ki pošilja zahtevek z eno ali veè datotekami in sprejme odgovor strežnika.

Program, ki izvaja manipulacije frekvenènega spektra, upošteva lastnosti hitre Fourierjeve transformacije in pravilno obdeluje zvok. Zavržemo del frekvenènega spektra, ki je zrcalna slika relevantnega dela. Transformacije, ki jih izvajamo na preostanku, so zato smiselne in se obnašajo kot prièakovano.

\vspace{10pt}

% povezovanje v enoten sistem

\section{Meritve}

Naš problem predstavlja veliko raèunsko breme gruèi ampak relativno majhno breme za prenos podatkov prek omrežja. Na enem vozlišèu traja obdelovanje 5 sekund zvoka okrog 40 sekund. Algoritem je hitrostnega razreda $O(n * log(n))$.

Zaradi tipa problema in bremena nas zanimajo èasi raèunanja (procesiranja na gruèi, wall-clock time, v odvisnosti od števila uporabljenih vozlišè in velikosti bremena), prenosa podatkov na in iz gruèe (latenca omrežja - èas prenosa je najbrž zanemarljiv, saj so datoteke velike med 1MB in 15MB), latence prenosa podatkov med vozlišèi v gruèi (da vidimo, ali je paralelizacija na gruèi primerna ali bi bilo bolje uporabljati paralelizacijo na veè jedrih ali podobni arhitekturi) in najveèje število datotek, ki jih lahko obdeluje hkrati, preden se gruèa ali deli nje sesujejo.

Izvajamo veè meritev:
\begin{itemize}
\item celoten èas izvajanja storitve od trenutka, ko klient zaène pošiljati podatke, do trenutka, ko se do konca prenese odgovor strežnika.
\item èas izvajanja raèunskega dela storitve od klica programa FFT do konca njegovega izvajanja.
\item èas prejemanja in pošiljanja podatkov prek omrežja.
\item èas pošiljanja podatkov med raèunalniki v gruèi po lokalnem omrežju (klici funkcij MPI scatter in MPI gather.
\item skupna hitrost obdelava podatkov v bajtih na sekundo.
\end{itemize}

Meritev èasa izvajanja raèunanja in meritev èasa prenosa podatkov med procesi smo ponovili tudi na raèunalniku s procesorjem Intel i5-3317U, s frekvenco ure 1,7GHz in 4GB DDR3 delovnega spomina in 3MB L3 cache-a. Pri tem smo program izvajali lokalno, brez strežnika. Rezultati nam dajo primerjavo med veèjedrnim procesorjem s hyperthreadingom in gruèo enojedrnih. Bralec lahko primerja tudi zmogljivost glede na ceno, pri èimer mora vedeti, da raèunalnik Raspberry Pi stane okrog 30 evrov, stikalo, ki smo ga uporabili, stane 40 evrov do 100 evrov, raèunalnik z Intelovim procesorjem, ki smo ga uporabili, pa okrog 800 evrov.

%%% TODO ker swittch mamo

Mertive smo izvedli na 1, 2 in 4 raèunalnikih v gruèi. Izvedli smo teste z enim 1, 5, 20, 60 in 180 sekund dolgo vhodno zvoèno datoteko in z 1, 5 in 10 vhodnimi datotekami velikosti 5 sekund. Posebej smo testirali še veè datotek po 180 sekund, s èimer smo uspeli sesuti gruèo.

Zaradi zelo dolgega èasa izvajanja storitve za datoteke, dolge 180s, smo to meritev izvajali le na vseh 4 raèunalnikih v gruèi in na procesorju Intel i5.

Vse teste smo ponovili trikrat.  

%%======================== konst num = 1, var size =======================
%%============================= èas zahtevka =============================

\subsection{Izmerjeni èasi: 1 datoteka, razliène velikosti datoteke}
Meritev celotnega èasa izvajanja storitve od trenutka, ko klient zaène pošiljati podatke, do trenutka, ko se do konca prenese odgovor strežnika. 
\begin{table}[h]
\begin{tabular}{l|ccccc}
RPIs & n[s] = 1  & n[s] = 5  & n[s] = 20  & n[s] = 60  & n[s] = 180 \\ \cline{1-6}
1    & 6,36      &    21,85  &    86,11   &   359,54   & -          \\
     & 6,23      &    20,70  &    85,98   &   361,90   & -          \\
     & 6,48      &    21,73  &    84,97   &   363,97   & -          \\ \cline{1-6}

2    & 5,27      &    14,50  &    44,69   &   179,31   &  -         \\
     & 5,23      &    14,08  &    48,99   &   179,84   &  -         \\
     & 5,20      &    13,08  &    48,35   &   178,99   &  -         \\ \cline{1-6}

4    & 8,26      &    10,67  &    27,85   &    94,49   &    193,99  \\
     & 9,31      &    10,66  &    28,50   &    93,18   &    203,01  \\
     & 9,34      &    11,06  &    27,15   &    97,29   &    201,75  \\
\end{tabular}
\caption{Tabela izmerjenih vrednosti èasa izvajanja celotnega zahtevka.}
\end{table}

\begin{figure}[H]
\centerline{\includegraphics[scale=1]
{4_dolzinaDatotek.eps}}
\caption{Graf èasa celotnega izvajanja zahtevka.}
\label{fig:zahtevek1}
\end{figure}

Na grafu \ref{zahtevek1} vidimo, da se, ko podvojimo število vozlišè v gruèi, èas izvajanja v skoraj razpolovi. Iz grafa \ref{casfft1} lahko vidimo, da je razlika med linearno pohitritvijo in doseženo pohitritvijo predvsem posledica daljšega prenosa podatkov prek omrežja, ki seveda ni odvisen od velikosti gruèe.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ÈAS OMREŽJA V SEKUNDAH ZA 1 FAJL

\subsection{Izmerjeni èasi prenosa podatkov in režije (angl. \textit{overhead}) v sekundah: 1 datoteka, razliène velikosti datoteke}

\begin{table}[h]
\begin{tabular}{l|ccccc}
RPIs & n[s] = 1  & n[s] = 5  & n[s] = 20  & n[s] = 60  & n[s] = 180 \\ \cline{1-6}
1    & 0,17      & 0,29      & 1,57       & 4,40       &  -         \\
     & 0,12      & 0,36      & 1,24       & 3,83       &  -         \\
     & 0,12      & 0,35      & 1,09       & 3,82       &  -         \\ \cline{1-6}

2    & 0,13      & 0,34      & 1,28       & 3,79       &  -         \\
     & 0,12      & 0,34      & 1,47       & 4,16       &  -         \\
     & 0,15      &  0,68     & 1,12       & 3,79       &  -         \\ \cline{1-6}

4    &  0,66     &  1,59     &  5,25      &  4,35      &  17,96     \\
     &  0,46     &  4,65     &  7,90      &  8,32      &  20,09     \\
     &  0,78     &  2,06     &  8,32      &  7,39      &  19,61     \\ %% idelno ponoviti tretjo meritev za 180 - net zajbava
\end{tabular}
\caption{Tabela izmerjenih vrednosti èasa prenosa podatkov na prek omrežja na gruèo.}
\end{table}



%%================================ hitrost raèunanja ============================= bajti na service

\subsection{Izmerjena hitrost obdelave podatkov v kB/s: 1 datoteka, razliène velikosti datoteke}

\begin{table}[h]
\begin{tabular}{l|cccc}
RPIs & n[s] = 1  & n[s] = 5  & n[s] = 20  & n[s] = 60  \\ \cline{1-6}
1    & 9636      & 19781     & 20137      & 14434      \\
     & 10871     & 18099     & 20684      & 14948      \\
     & 10872     & 18872     & 20245      & 14863      \\ \cline{1-6}
                                                       
2    & 14429     & 33045     & 38939      & 30263      \\
     & 12404     & 30738     & 37932      & 29522      \\
     & 14356     & 32215     & 39086      & 29255      \\ \cline{1-6}
                                                       
4    &  17298    &  47105    &  70233     & 57326      \\
     &  17392    &  45511    &  70452     & 56347      \\
     &  17230    &  47181    &  70283     & 58203      \\
\end{tabular}
\caption{Tabela izmerjenih vrednosti hitrosti obdelave podatkov. n[s] je dolžina zvoène datoteke v sekundah, RPIs pomeni število vozlišè v gruèi.}
\end{table}

\begin{figure}[H]
\centerline{\includegraphics[scale=1]
{4_pretocnost.eps}}
\caption{Graf hitrosti obdelave podatkov.}
\label{fig:pretocnost}
\end{figure}

Na grafu \ref{fig:pretocnost} vidimo primerjave hitrosti obdelave podatkov za celotno storitev (velikost datoteke v kilobajtih deljena s èasom, kot ga vidi klient). Zanimivo je, da je oèitno okrog datotek velikosti 20 sekund optimalna toèka, pri kateri se èasi obdelave podatkov, prenosa podatkov in latenca omrežja pridejo v za uporabnika najboljše razmerje. Lahko razberemo tudi, da je hitrost obdelave odvisno skoraj linearno od števila raèunalnikov v sistemu. To pomeni, da še nismo dosegli maksimalne pohitritve po Amdahlovem zakonu in bi s podvojitvijo števila raèunalnikov lahko še vsaj enkrat podvojili zmogljivost gruèe.


%%%%%%%%%%%%%%%%%%%%%% FFT ÈAS NA GRUÈI
\subsection{Izmerjen èas raèunananja FFT v sekundah: 1 datoteka, razliène velikosti datoteke}

\begin{table}[h]
\begin{tabular}{l|ccccc}
RPIs & n[s] = 1  & n[s] = 5  & n[s] = 20  & n[s] = 60      \\ \cline{1-6}
1    & 4,71      & 18,16     & 82,15      & 357,95         \\
     & 5,15      & 18,70     & 79,56      & 345,43         \\
     & 4,26      & 19,90     & 82,18      & 348,29         \\ \cline{1-6}

2    & 2,16      & 9,23      & 39,93      & 166,33         \\
     & 2,15      & 9,64      & 41,16      & 171,19         \\
     & 2,12      & 9,24      & 39,71      & 173,15         \\ \cline{1-6}

4    &   1,13    &  4,65    &  19,45      & 84,26          \\
     &   1,11    &  4,54    &  19,98      & 85,31          \\
     &   1,07    &  4,67    &  19,47      & 82,40          \\
\end{tabular}
\caption{Tabela izmerjenih vrednosti èasa izvajanja algoritma FFT. n[s] pomeni dolžina zvoène datoteke v sekundah, RPIs pa število vozlišè v gruèi.}
\end{table}

V tabeli lahko vidimo, da je pohitritev pri dodajanju vozlišè v gruèo superlinearna. To se pri porazdeljevanju programa skoraj nikoli ne zgodi. V našem primeru je do tega prišlo, ker nalogo nazdelimo na manjše podprobleme na drugaèen naèin, kot je to standardno pri FFT. Ponavadi se pri FFT zvoèno datoteko razdeli na lihe in sode vzorce, mi pa smo celotno datoteko razdelili na veè manjših. Ob tem sicer izgubimo na kvaliteti zvoka, vendar to zaradi velikosti datotek ni problematièno, saj se v praksi ponavadi stori isto, vendar na še mnogo veè mnogo manjših kosov, kot smo to storili mi. Razlika v kvaliteti zvoka ni opazna za èloveka. Rezlutat tega je, da zahtevnost algoritma pade in pride do rahlo superliearne pohitritve. Glej poglavje zakljuèek \ref{sec:zakljucek}. 

%%%%%%%%%%%%%%%%%%% FFT ÈAS NA INTELU
\subsection{Èas izvajanja algoritma FFT na raèunalniku s procesorjem i5, za primerjavo raèunske zmogljivosti}

\begin{table}[h]
\begin{tabular}{l|ccccc}
št. jeder & n[s] = 1  & n[s] = 5  & n[s] = 20  & n[s] = 60  & n[s] = 180 \\ \cline{1-6}
1    & 1,15      & 4,84      & 21,56      & 86,54      & 133,01     \\
     & 1,07      & 4,76      & 19,74      & 86,91      & 187,35     \\
     & 1,07      & 4,57      & 17,65      & 86,50      & 179,31     \\ \cline{1-6}

2    & 0,79      & 3,33      & 12,89      & 50,69      & 112,80     \\
     & 0,63      & 2,63      & 11,51      & 49,31      & 73,87      \\
     & 0,66      & 2,74      & 11,26      & 48,28      & 107,95     \\ \cline{1-6}
 
4    & 0,50      & 1,87      & 7,85       & 33,92      & 71,17      \\
     & 0,41      & 1,76      & 7,38       & 31,56      & 68,11      \\
     & 0,46      & 1,84      & 7,43       & 31,46      & 66,88      \\
\end{tabular}
\end{table}

\begin{figure}[H]
\centerline{\includegraphics[scale=1]
{4_obdelava.eps}}
\caption{Graf èasov izvajanja obdelave podatkov.}
\label{fig:obdelava}
\end{figure}

Na grafu \ref{fig:obdelava} vidimo primerjavo èasov izvajanja algoritma FFT. Na abscisni osi so razliène dolžine datotek, na ordinatni pa èas izvajanja. Skala je povsod linearna. Razlièni grafi predstavljajo meritve razliènih konfiguracij sistema. Najhitrejši, oznaèen kot Intel i5, je en dvojedrni procesor s hyperthreadingom. Glede na celotno ceno sistema se gruèa izkaže za boljšo rešitev.
Zanimiva je tudi primerjava med gruèo z razliènim številom vozlišè, saj je pohitritev praktièno linearno odvisna od števila vozlišè v gruèi.





















































%%%====================== konst size = 5s, var num =======================
%%============================= èas zahtevka =============================
%\iffalse

\subsection{Izmerjeni èasi izvajanja celotnega zahtevka: datoteka dolga 5s, razlièno število datotek v zahtevku}

\begin{table}[h]
\begin{tabular}{l|ccc }
RPIs & N[f] = 1 & N[f] = 5 & N[f] = 10 \\ \cline{1-4}
1    & 21,85 & 102,38 & 208,68 \\
     & 20,70 & 104,35 & 203,89 \\
     & 21,73 & 103,75 & 218,35 \\ \cline{1-4}

2    & 14,50 &  70,95 & 126,58 \\
     & 14,08 &  70,32 & 150,61 \\
     & 13,08 &  71,55 & 129,25 \\ \cline{1-4}

4    & 10,67 &  55,44 &  98,99 \\
     & 10,66 &  55,93 &  95,94 \\
     & 11,06 &  55,80 &  95,94 \\
\end{tabular}
\caption{Tabela izmerjenih vrednosti celotnega izvajanja zahtevka. N[f] pomeni število zvoènih datoteke dolžine 5 sekund, RPIs pa število vozlišè v gruèi.}
\end{table}

\begin{figure}[H]
\centerline{\includegraphics[scale=1]
{4_razlicnoSteviloDatotek.eps}}
\caption{Graf èasov izvajanja celotnega zahtevka za veè datotek.}
\label{fig:obdelava}
\end{figure}

Iz grafa \ref{fig:obdelava} vidimo, da je èas izvajanja približno linearno odvisen od števila datotek. To je razumljivo, saj gre za veè ponovitev enakega zahtevka. Èe bi število datotek zelo poveèali, bi najbrž prišlo do velike upoèasnitve, ko bi zaèelo zmanjkovati spomina na gruèi, vendar se ob tem skoraj istoèasno tudi gruèa sesuje, ker je zaradi majhnega zunanjega pomnilnika (SSD kartica) zelo malo swap prostora, kar pomeni, da zmanjka celotnega pomnilnika skoraj istoèasno kot delovnega pomnilnika. Glej poglavje \ref{sec:zakljucek}.

%%============================= overheadm MPI graf hoèm =============================

\subsection{Izmerjeni èasi pošiljanja podatkov po gruèi: datoteka dolga 5s, razlièno število datotek v zahtevku}

\begin{table}[h]
\begin{tabular}{l|cccc}
RPIs & N[f] = 5 & N[f] = 10 \\ \cline{1-3}
1    & 0,024 & 0,047 \\
     & 0,024 & 0,048 \\
     & 0,025 & 0,048 \\ \cline{1-3}

2    & 0,542 & 1,10 \\
     & 0,548 & 1,15 \\
     & 0,549 & 1,09 \\ \cline{1-3}

4    & 0,841 & 1,64 \\
     & 0,816 & 1,63 \\
     & 0,810 & 1,69 \\
\end{tabular}
\label{mpiovermany}
\end{table}

Iz tabele \ref{mpiovermany} vidimo, da so èasi porazdelitve podatkov po gruèi (MPI scatter in gather funkciji) zelo manjhni in predstavljajo reda 1% celotnega èasa izvajanja.

%%================================ hitrost raèunanja ============================= FFT

\subsection{Izmerjena hitrost obdelave podatkov v kB/s: datoteka dolga 5s, razlièno število datotek v zahtevku}

\begin{table}[h]
\begin{tabular}{l|cccc}
RPIs & N[f] = 5 & N[f] = 10 \\ \cline{1-3}
1    & 93,73 & 192,83 \\
     & 93,73 & 186,84 \\
     & 92,90 & 186,84 \\ \cline{1-3}

2    & 45,90 & 91,97 \\
     & 46,30 & 96,69 \\
     & 47,64 & 92,45 \\ \cline{1-3}

4    & 23,47 & 47,19 \\
     & 23,23 & 46,48 \\
     & 23,42 & 48,38 \\
\end{tabular}
\end{table}

%%================================ hitrost raèunanja ============================= seervice

\subsection{Izmerjena hitrost obdelave podatkov v kB/s: datoteka dolga 5s, razlièno število datotek v zahtevku}

\begin{table}[h]
\begin{tabular}{l|cccc}
RPIs & N[f] = 5   & N[f] = 10  \\ \cline{1-3}
1    & 18861 & 18443 \\
     & 18789 & 18996 \\
     & 19118 & 18133 \\ \cline{1-3}

2    & 32230 & 31850 \\
     & 31792 & 30810 \\
     & 31148 & 31847 \\ \cline{1-3}

4    & 47518 & 47360 \\
     & 47514 & 47364 \\
     & 47544 & 43176 \\
\end{tabular}
\end{table}


























%\fi

\section{Zakljuèek} \label{sec:zakljucek}

Zaradi tipa algoritma (FFT se rekurzivno deli vedno na dva dela, zato deluje dobro le, èe uporabljamo $2^n$ paralelnih niti, kar je tudi razlog, da po zaèetnem poskusu nismo opravljali testov na gruèi velikosti 3.

Ker za dovolj velik $n$ velja $n*log(n) > n*log(n/m)*m$, je hitrost reševanja problem veèja, èe rešujemo veè manjših problem, kot enega velikega. To je razlog, da ne porazdeljujemo po gruèi po drevesu razcepa podatkov, ki ga izvaja FFT, ampak razdelimo vse podatke na $m$ delov in nato odbelujemo vsakega posebej, pri èemer je $m$ število raèunalnikov v gruèi. To je slaba rešitev za zelo velik $m$ ali zelo majhne zahtevke, saj bi se lahko poznala izguba kvalitete zvoka, ki jo to prinese. Razlika se na normalnih zahtevkih in našem $m$ sicer ne pozna. Takšen pristop se uporablja tudi v praksi, predvsem kadar se izvaja transformacije v realnem èasu (sproti).

